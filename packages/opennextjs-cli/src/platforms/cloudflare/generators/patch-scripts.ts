/**
 * Patch Scripts Generator
 *
 * Generates patch scripts for setImmediate polyfill and Prisma WASM handling.
 *
 * @packageDocumentation
 */

import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { CloudflareConfig } from '../../../schemas/config.js';
import { logger } from '../../../utils/logger.js';

/**
 * Generates patch scripts for Cloudflare Workers compatibility
 *
 * @description
 * Creates patch scripts that handle:
 * - setImmediate polyfill for Next.js compatibility
 * - Prisma WASM module handling (if Prisma is detected)
 *
 * @param config - Cloudflare configuration
 * @param projectRoot - Root directory of the project
 * @returns Promise that resolves when scripts are generated
 *
 * @example
 * ```typescript
 * await generatePatchScripts(config, process.cwd());
 * ```
 */
export async function generatePatchScripts(
  config: CloudflareConfig,
  projectRoot: string
): Promise<void> {
  const scriptsDir = join(projectRoot, 'scripts');
  mkdirSync(scriptsDir, { recursive: true });

  // Generate pre-build patch script (for Next.js source)
  await generatePreBuildPatch(scriptsDir, config);

  // Generate post-build patch script (for OpenNext output)
  await generatePostBuildPatch(scriptsDir, config);

  logger.success('Generated patch scripts');
}

/**
 * Generates pre-build patch script
 *
 * @description
 * Creates a script that patches Next.js source files before build.
 * This handles setImmediate compatibility issues.
 *
 * @param scriptsDir - Directory to write scripts to
 * @param config - Cloudflare configuration
 */
async function generatePreBuildPatch(scriptsDir: string, config: CloudflareConfig): Promise<void> {
  const filePath = join(scriptsDir, 'patch-nextjs-source.js');

  const content = `#!/usr/bin/env node
/**
 * Pre-build patch script for Next.js Cloudflare Workers compatibility
 * 
 * This script patches Next.js source files to fix setImmediate compatibility
 * issues with Cloudflare Workers.
 * 
 * Generated by opennextjs-cli
 * Next.js Version: ${config.nextJsVersion}
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

const nodeModulesPath = join(
  process.cwd(),
  'node_modules/next/dist/server/node-environment-extensions/fast-set-immediate.external.js'
);

if (existsSync(nodeModulesPath)) {
  try {
    let content = readFileSync(nodeModulesPath, 'utf-8');
    let patched = false;

    // Remove nodeTimers.setImmediate assignments (read-only in Cloudflare Workers)
    if (content.includes('nodeTimers.setImmediate =') && !content.includes('// PATCHED:')) {
      content = content.replace(
        /globalThis\\.setImmediate\\s*=\\s*nodeTimers\\.setImmediate\\s*=/g,
        'globalThis.setImmediate ='
      );
      content = content.replace(
        /globalThis\\.clearImmediate\\s*=\\s*nodeTimers\\.clearImmediate\\s*=/g,
        'globalThis.clearImmediate ='
      );
      patched = true;
    }

    // Comment out nodeTimersPromises assignments (read-only module)
    if (content.includes('nodeTimersPromises.setImmediate =') && !content.includes('// PATCHED:')) {
      content = content.replace(
        /(\\s+)(const nodeTimersPromises = require\\('node:timers\\/promises'\\);)/g,
        '$1// PATCHED: $2\\n$1// Cloudflare Workers: nodeTimersPromises is read-only, skipping assignment'
      );
      content = content.replace(
        /(\\s+)(nodeTimersPromises\\.setImmediate\\s*=\\s*patchedSetImmediatePromise;)/g,
        '$1// PATCHED: $2 - Commented out because nodeTimersPromises is read-only in Cloudflare Workers'
      );
      patched = true;
    }

    if (patched) {
      content = '// PATCHED by opennextjs-cli\\n' + content;
      writeFileSync(nodeModulesPath, content, 'utf-8');
      console.log('✓ Patched Next.js source for Cloudflare Workers compatibility');
    }
  } catch (error) {
    console.warn('⚠ Could not patch Next.js source:', error?.message || String(error));
  }
} else {
  console.log('ℹ Next.js source file not found, skipping pre-build patch');
}
`;

  writeFileSync(filePath, content, 'utf-8');
  // Make executable
  if (process.platform !== 'win32') {
    const { chmodSync } = await import('fs');
    chmodSync(filePath, 0o755);
  }
}

/**
 * Generates post-build patch script
 *
 * @description
 * Creates a script that patches OpenNext.js output files after build.
 * This handles setImmediate polyfill and Prisma WASM module setup.
 *
 * @param scriptsDir - Directory to write scripts to
 * @param config - Cloudflare configuration
 */
async function generatePostBuildPatch(scriptsDir: string, config: CloudflareConfig): Promise<void> {
  const filePath = join(scriptsDir, 'patch-init.js');
  const isNextJs16 = config.nextJsVersion.startsWith('16');

  const content = `#!/usr/bin/env node
/**
 * Post-build patch script for OpenNext.js Cloudflare Workers
 * 
 * This script patches the generated worker.js and init.js files to:
 * - Add setImmediate polyfill at module level
 * - Handle Prisma WASM module (if Prisma is used)
 * 
 * Generated by opennextjs-cli
 * Next.js Version: ${config.nextJsVersion}
 * ${isNextJs16 ? '⚠️  Next.js 16.x experimental support' : ''}
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { globSync } from 'glob';

const moduleLevelPolyfill = \`// CRITICAL: Define setImmediate polyfill at module level before any imports
// This fixes the "Cannot assign to read only property 'setImmediate'" error
// Next.js's fast-set-immediate.external.js tries to patch setImmediate on a module object
// Must be defined before any Next.js code runs
if (typeof globalThis.setImmediate === 'undefined' || !Object.getOwnPropertyDescriptor(globalThis, 'setImmediate')?.writable) {
  const setImmediateImpl = (fn, ...args) => setTimeout(fn, 0, ...args);
  try {
    Object.defineProperty(globalThis, "setImmediate", {
      value: setImmediateImpl,
      writable: true,
      configurable: true,
      enumerable: false,
    });
  } catch (e) {
    try {
      globalThis.setImmediate = setImmediateImpl;
    } catch {
      // Silent fallback
    }
  }
}
if (typeof globalThis.clearImmediate === 'undefined') {
  Object.defineProperty(globalThis, "clearImmediate", {
    value: (id) => clearTimeout(id),
    writable: true,
    configurable: true,
    enumerable: false,
  });
}

\`;

// Patch worker.js
const workerJsPath = join(process.cwd(), '.open-next/worker.js');
if (existsSync(workerJsPath)) {
  try {
    let workerContent = readFileSync(workerJsPath, 'utf-8');
    
    if (!workerContent.startsWith('// CRITICAL: Define setImmediate polyfill')) {
      workerContent = moduleLevelPolyfill + workerContent;
      writeFileSync(workerJsPath, workerContent, 'utf-8');
      console.log('✓ Added setImmediate polyfill to worker.js');
    } else {
      console.log('✓ setImmediate polyfill already exists in worker.js');
    }

    // Remove nodeTimers.setImmediate assignments from bundled code
    if (workerContent.includes('nodeTimers.setImmediate')) {
      workerContent = workerContent.replace(
        /globalThis\\.setImmediate\\s*=\\s*nodeTimers\\.setImmediate\\s*=/g,
        'globalThis.setImmediate ='
      );
      workerContent = workerContent.replace(
        /nodeTimers\\.setImmediate\\s*=\\s*/g,
        ''
      );
      workerContent = workerContent.replace(
        /globalThis\\.clearImmediate\\s*=\\s*nodeTimers\\.clearImmediate\\s*=/g,
        'globalThis.clearImmediate ='
      );
      workerContent = workerContent.replace(
        /nodeTimers\\.clearImmediate\\s*=\\s*/g,
        ''
      );
      writeFileSync(workerJsPath, workerContent, 'utf-8');
      console.log('✓ Removed nodeTimers assignments from bundled code');
    }
  } catch (error) {
    console.warn('⚠ Could not patch worker.js:', error?.message || String(error));
  }
} else {
  console.log('ℹ worker.js not found, skipping patch');
}

// Patch init.js
const initJsPath = join(process.cwd(), '.open-next/cloudflare/init.js');
if (existsSync(initJsPath)) {
  try {
    let content = readFileSync(initJsPath, 'utf-8');
    
    if (!content.startsWith('// CRITICAL: Define setImmediate polyfill')) {
      content = moduleLevelPolyfill + content;
      writeFileSync(initJsPath, content, 'utf-8');
      console.log('✓ Added setImmediate polyfill to init.js');
    } else {
      console.log('✓ setImmediate polyfill already exists in init.js');
    }
  } catch (error) {
    console.warn('⚠ Could not patch init.js:', error?.message || String(error));
  }
} else {
  console.log('ℹ init.js not found, skipping patch');
}

// Prisma WASM handling (if Prisma is detected)
// Note: This is a simplified version. Full Prisma support requires more complex patching.
const prismaClientPath = join(process.cwd(), 'node_modules/.prisma/client');
if (existsSync(prismaClientPath)) {
  console.log('ℹ Prisma detected. For full Prisma WASM support, see: https://opennext.js.org/cloudflare/troubleshooting');
}
`;

  writeFileSync(filePath, content, 'utf-8');
  // Make executable
  if (process.platform !== 'win32') {
    const { chmodSync } = await import('fs');
    chmodSync(filePath, 0o755);
  }
}
